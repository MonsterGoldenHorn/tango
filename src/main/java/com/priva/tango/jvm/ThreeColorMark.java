package com.priva.tango.jvm;

/**
 * 三色标记
 */
public class ThreeColorMark {
    /**
     * java和Golang 的gc都有三色标记
     * 广度遍历bfs
     * 把roots引用的对象画一个多叉数，节点引用再类推，最后就是层序
     * 层序遍历，从root找待处理的，从待处理的找下一层，直到最后清楚不可达的
     */
    /**
     * java三色 cms,g1?
     * 1.初始标记，stw,遍历gcRoots
     * 2.并发标记，遍历灰色
     * 3.重新标记，解决黑色对象运行时引用到无关联的白色对象问题
     * 4.并发清除白色
     *
     * 解决漏标问题
     * 增量更新、原始快照。
     * CMS 回收器使用的增量更新方案，在黑色重新引用时记录自己，第三阶段以黑色记录作为root再标记一次
     * G1 采用的是原始快照方案，在灰色删除引用时，第三阶段以灰色记录作为root
     *
     * 对象消失问题的两个条件：
     * 插入了一条或多条从黑色对象到白色对象的新引用
     * 删除了全部从灰色对象到该白色对象的直接或间接引用
     *
     * 实现方式
     * 读写屏障（类aop）将引用赋值为读，引用修改为写（置空就是写，空赋值就是读）
     * 写屏障：尝试保留开始时的对象图，即原始快照（Snapshot At The Beginning，SATB）
     * 读屏障：不要求保留原始快照，而是针对新增的引用，将其记录下来等待遍历，即增量更新（Incremental Update）
     */
    /**
     * go
     * 1.初始对象全部都是白色
     * 2.gc前第一次遍历gcRoots可达对象全部标记为灰色
     * 3.第二次遍历所有灰色，将可达对象标记为灰色，将自己标记为黑色
     * 4.循环3到不存在灰色，最后回收白色
     *
     * 漏标
     * 黑色对象运行再次产生引用的对象（同时灰色持有），灰色断开引用（没有其他对象再关联此时的白色对象），此时，白色对象会被回收，黑色的引用将会丢失
     *
     * 使用强弱三色解决问题
     */
}
