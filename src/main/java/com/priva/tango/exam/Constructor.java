package com.priva.tango.exam;

/**
 * @description
 * @date 2023/10/17 13:48
 */
public class Constructor {
    /**
     * 业务需求分析之后软件设计之前进行架构，架构设计就是需求分配，即将满足需求的职责分配到组件上
     *
     * 架构的本质
     * 1、软件架构为软件系统提供了一个结构、行为和属性的高级抽象。
     * 2、软件架构风格是特定应用领域的惯用模式，架构定义一个词汇表和一组约束。
     * 架构的作用
     * 1、软件架构是项目干系人进行交流的手段
     * 2、软件架构是可传递和可复用的模型，通过研究软件架构可能预测软件的质量。
     * 3、软件架构使推理和控制的更改更加简单，有助于循序渐进的原型设计，可以作为培训的基础。
     */
    /**
     * 逻辑视图     开发视图
     *      场景视图
     * 过程视图     物理视图
     *
     *  >>>    4+1 视图模型认为，一个完整的软件设计模型，应该包括 5 部分的内容:
     * 逻辑视图:描述软件的功能逻辑，由哪些模块组成，模块中包含哪些类，其依赖关系如何。
     *      最终用户：功能需求
     * 开发视图:包括系统架构层面的层次划分，包的管理，依赖的系统与第三方的程序包。开发视图某些方面和逻辑视图有一定重复性，不同视角看到的可能是同一个东西，开发视图中一个程序包，可能正好对应逻辑视图中的一个功能模块。
     *      编程人员：软件管理
     * 过程视图: 描述程序运行期的进程、线程、对象实例，以及与此相关的并发、同步、通信等问题。
     *      系统集成人员：性能可扩充性，吞吐两
     * 物理视图:描述软件如何安装并部署到物理的服务上，以及不同的服务器之间如何关联、通信。
     *      系统工程人员：系统拓扑，安装，通信等
     * 场景视图:针对具体的用例场景，将上述 4 个视图关联起来，一方面从业务角度描述，功能流程如何完成，一方面从软件角度描述，相关组成部分如何互相依赖、调用。
     */
    /**
     * 架构风格
     *
     * 五大架构风格	    子风格
     *
     * 数据流风格	        批处理（数据必须是完整的，以整体的方式传递，无需用户交互）、管道-过滤器（管道支持数据流或流式处理，弱用户交互）
     *      视频流，编译器等
     * 调用/返回风格	    主程序/子程序、面向对象、层次结构
     *      优点：利于复用，可维护，可扩展好
     *      缺点：不好分层，耦合高的更难
     *      特点：各个层次的组件形成不同功能级别的虚拟机;多层相互协同工作，而且实现透明。
     * 独立构件风格	    进程通信、事件驱动系统(隐式调用)
     *      进程通信：构件是独立的过程，连接件是消息传递，构件通常是命名过程，消息传递的方式可以是点对点、异步或同步方式，以及远程过程（方法）调用等
     *      事件驱动系统（隐式调用）：构件不直接调用一个过程，而是触发或广播一个或多个事件
     *      优点：松耦合，高复用扩展修改
     *      缺点：失去调用控制，无法保证结果
     * 虚拟机风格	        解释器、规则系统
     *      解释器：通常包括一个完成解释工作的解释引擎，一个包含将被解释的代码存储区、一个记录解释引擎当前工作状态的数据结构，以及一个记录源代码被解释执行的进度的数据结构。
     *      基于规则的系统：基于规则的系统包括规则集、规则解释器、规则／数据选择器和工作内存，一般在人工智能领域和DSS中。专家系统
     *      java虚拟机，class文件运行
     * 仓库风格	        数据库系统、黑板系统、超文本系统
     *      仓库风格中的构件分为两种：一种是中央数据结构，保存系统的当前状态；另一种是独立构件，对中央数据存储进行操作
     *      黑板系统：包括知识源、黑板和控制三部分
     *      超文本系统：构件以网状链接方式相互连接
     */
}
