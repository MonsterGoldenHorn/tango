package com.priva.tango.cloud;

public class CloudMain {
    /**
     * 与springboot 版本搭配
     * https://spring.io/projects/spring-cloud#overview
     * https://start.spring.io/actuator/info
     * "Hoxton.SR12": "Spring Boot >=2.2.0.RELEASE and <2.4.0.M1",
     * "2020.0.4": "Spring Boot >=2.4.0.M1 and <2.5.8-SNAPSHOT",
     * "2020.0.5-SNAPSHOT": "Spring Boot >=2.5.8-SNAPSHOT and <2.6.0-M1",
     * "2021.0.0-M1": "Spring Boot >=2.6.0-M1 and <2.6.0-M3",
     * "2021.0.0-M3": "Spring Boot >=2.6.0-M3 and <2.6.0-RC1",
     * "2021.0.0-RC1": "Spring Boot >=2.6.0-RC1 and <2.6.2-SNAPSHOT",
     * "2021.0.0-SNAPSHOT": "Spring Boot >=2.6.2-SNAPSHOT"
     */
    /**
     * 什么是微服务？
     * 微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，
     * 每个服务运行在其独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。
     * 服务之间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。
     * 每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。
     * 另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，
     * 可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。
     */
    /**
     * 通讯方式
     * 1）rpc  同步，请求双方服务必须在线
     * 2）mq   异步，支持订阅发布等，但同时增加了复杂度
     */
    /**
     * springcloud 与dubbo有哪些区别
     *
     * SpringCloud 和Dubbo可以实现RPC远程调用框架，可以实现服务治理。
     * Dubbo内部实现功能没有SpringCloud强大（全家桶），只是实现服务治理，缺少分布式配置中心、网关、链路、总线等，如果需要用到这些组件，需要整合其他框架。
     * 只是比传统项目多了服务注册，减少了服务的相互引用
     */
    /**
     * springBoot 和SpringCloud
     *
     * SpringBoot专注于快速方便的开发单个个体微服务。
     * SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、
     *      断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务。
     * SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖的关系。
     * SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。
     */
    /**
     * “Design for Failure”：为失败而设计。微服务架构可以在发生故障时通过合理的行为快速做出错误隔离和恢复机制，提供高可用性的服务
     *
     * 服务雪崩：由于服务间相互调用，最终压力来到某一个服务，如果卡顿或者掉线，导致其他调用依赖的服务不可用
     * 服务依赖的保护主要有以下三种解决方案:
     * 1)熔断模式
     *
     * 2)隔离模式
     *  1.线程池隔离
     *  Spring Cloud Hystrix则实现了进程内部线程池的隔离，通过给每个依赖服务分配独立的线程池进行资源隔离，从而避免服务雪崩
     *  相当于每个接口(服务)都有自己独立的线程池，不同的线程池之间互不影响，能够实现服务接口隔离。缺点：CPU内存开销较大
     *
     *  tomcat单应用隔离或者开启应用指定线程池
     *  2.进程隔离
     *  Docker通过“舱壁隔离”实现了进程的隔离，使得容器与容器之间不会互相影响
     *  3.信号量隔离机制
     * 信号量semaphore是一个并发工具类，用来控制可同时并发的线程数。其内部维护了一组虚拟许可，通过构造器指定许可的数量，每次线程执行操作时先通过acquire方法获得许可，
     * 执行完毕再通过release方法释放许可。如果无可用许可，那么acquire方法将一直阻塞，直到其他线程释放许可。在信号量隔离机制下，接收请求和执行下游依赖在同一个线程内完成，不存在线程上下文切换所带来的性能开销。
     * 信号量的资源隔离只是起到开关的作用，比如，服务A的信号量大小为10，那么就是说它同时只允许有10个Tomcat线程来访问服务A，其他请求都会被拒绝，从而达到资源隔离和限流保护的作用。
     *
     * 3)限流模式
     * 在高并发的情况下，防止用户一直等待，使用服务降级方式进行处理(返回友好的提示给客户端，fallback回调方法)。当服务不可用的时候(正在等待的时候、网络延迟、
     * 响应时间过长),客户端会处于一直等待的状态。显然一直等待是不合理的，所以我们应该给客户端返回一个友好的提示，使用fallback(回调方法)进行服务降级处理
     */
}
